package com.example.iotserver.service;

import com.influxdb.client.InfluxDBClient;
import com.influxdb.client.QueryApi;
import com.influxdb.client.WriteApiBlocking;
import com.influxdb.client.domain.WritePrecision;
import com.influxdb.client.write.Point;
import com.influxdb.query.FluxRecord;
import com.influxdb.query.FluxTable;
import com.example.iotserver.config.InfluxDBConfig;
import com.example.iotserver.dto.SensorDataDTO;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class SensorDataService {

    private final WriteApiBlocking writeApi;
    private final InfluxDBClient influxDBClient;
    private final InfluxDBConfig influxDBConfig;

    /**
     * Save sensor data to InfluxDB
     */
    public void saveSensorData(SensorDataDTO data) {
        try {
            Point point = Point.measurement("sensor_data")
                    .addTag("device_id", data.getDeviceId())
                    .addTag("sensor_type", data.getSensorType() != null ? data.getSensorType() : "UNKNOWN") // Th√™m ki·ªÉm
                                                                                                            // tra null
                    .addTag("farm_id", String.valueOf(data.getFarmId()))
                    .time(data.getTimestamp(), WritePrecision.MS);

            // VVVV--- TH√äM LOG DEBUG CHI TI·∫æT ---VVVV
            log.info(">>>> [INFLUX WRITE] Preparing to write Point for device {}", data.getDeviceId());
            // ^^^^-------------------------------^^^^

            // VVVV--- TH√äM ƒê·∫¶Y ƒê·ª¶ C√ÅC TR∆Ø·ªúNG ---VVVV
            if (data.getTemperature() != null)
                point.addField("temperature", data.getTemperature());
            if (data.getHumidity() != null)
                point.addField("humidity", data.getHumidity());
            if (data.getSoilMoisture() != null)
                point.addField("soil_moisture", data.getSoilMoisture());
            if (data.getLightIntensity() != null)
                point.addField("light_intensity", data.getLightIntensity());
            if (data.getSoilPH() != null)
                point.addField("soilPH", data.getSoilPH());
            // ^^^^-----------------------------^^^^

            // N·∫øu kh√¥ng c√≥ field n√†o ƒë∆∞·ª£c th√™m, kh√¥ng ghi ƒë·ªÉ tr√°nh l·ªói
            if (point.hasFields()) {
                writeApi.writePoint(point);
                log.debug("Saved sensor data for device: {}", data.getDeviceId());
            } else {
                log.warn("No fields to write for device {}, skipping InfluxDB write.", data.getDeviceId());
            }

        } catch (Exception e) {
            log.error("Error saving sensor data to InfluxDB: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to save sensor data", e);
        }
    }

    // File: SensorDataService.java

    /**
     * Get latest sensor data for a device by pivoting fields into a single record.
     * ‚úÖ S·ª¨A: TƒÉng range l√™n 24h ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ d·ªØ li·ªáu
     */
    public SensorDataDTO getLatestSensorData(String deviceId) {
        try {
            log.info("üîç [InfluxDB] Getting latest data for device: {}", deviceId);

            // ‚úÖ S·ª¨A ƒê·ªîI QUERY: Th√™m pivot() ƒë·ªÉ g·ªôp c√°c fields l·∫°i th√†nh m·ªôt h√†ng duy nh·∫•t
            String query = String.format(
                    "from(bucket: \"%s\")\n" +
                            "  |> range(start: -1h)\n" +
                            "  |> filter(fn: (r) => r[\"_measurement\"] == \"sensor_data\")\n" +
                            "  |> filter(fn: (r) => r[\"device_id\"] == \"%s\")\n" +
                            "  |> last()\n" +
                            "  |> pivot(rowKey:[\"_time\"], columnKey: [\"_field\"], valueColumn: \"_value\")",
                    influxDBConfig.getBucket(), deviceId);

            log.debug("üîç [InfluxDB] Executing Pivot Query: {}", query);

            QueryApi queryApi = influxDBClient.getQueryApi();
            List<FluxTable> tables = queryApi.query(query, influxDBConfig.getOrg());

            if (tables.isEmpty() || tables.get(0).getRecords().isEmpty()) {
                log.warn("‚ùå [InfluxDB] No data found for device: {} in the last hour.", deviceId);
                return null;
            }

            // V·ªõi pivot(), ch√∫ng ta ch·ªâ c·∫ßn x·ª≠ l√Ω record ƒë·∫ßu ti√™n
            FluxRecord record = tables.get(0).getRecords().get(0);
            Map<String, Object> values = record.getValues();

            SensorDataDTO sensorData = SensorDataDTO.builder()
                    .deviceId(deviceId)
                    .timestamp(record.getTime())
                    .temperature(getDoubleValue(values, "temperature"))
                    .humidity(getDoubleValue(values, "humidity"))
                    .soilMoisture(getDoubleValue(values, "soil_moisture"))
                    .lightIntensity(getDoubleValue(values, "light_intensity"))
                    .soilPH(getDoubleValue(values, "soilPH"))
                    .build();

            log.info("‚úÖ [InfluxDB] Successfully retrieved latest data for {}: {}", deviceId, sensorData);
            return sensorData;

        } catch (Exception e) {
            log.error("‚ùå [InfluxDB] Error querying latest sensor data for {}: {}", deviceId, e.getMessage(), e);
            return null; // Tr·∫£ v·ªÅ null khi c√≥ l·ªói
        }
    }

    // ‚úÖ TH√äM HELPER METHOD N√ÄY: L·∫•y gi√° tr·ªã Double t·ª´ map m·ªôt c√°ch an to√†n
    private Double getDoubleValue(Map<String, Object> map, String key) {
        Object value = map.get(key);
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return null;
    }

    /**
     * Get sensor data for a time range
     */
    public List<SensorDataDTO> getSensorDataRange(
            String deviceId,
            Instant start,
            Instant end) {
        String flux = String.format(
                "from(bucket: \"%s\") " +
                        "|> range(start: %s, stop: %s) " +
                        "|> filter(fn: (r) => r[\"device_id\"] == \"%s\") " +
                        "|> sort(columns: [\"_time\"])",
                influxDBConfig.getBucket(),
                start.toString(),
                end.toString(),
                deviceId);

        List<Map<String, Object>> rawDataList = executeQueryList(flux);
        return rawDataList.stream()
                .map(SensorDataDTO::fromInfluxRecord)
                .collect(Collectors.toList());
    }

    /**
     * Get aggregated sensor data (for charts)
     */
    public List<SensorDataDTO> getAggregatedData(
            String deviceId,
            String field,
            String aggregation, // mean, max, min
            String window // 1m, 5m, 1h, 1d
    ) {
        String flux = String.format(
                "from(bucket: \"%s\") " +
                        "|> range(start: -7d) " +
                        "|> filter(fn: (r) => r[\"device_id\"] == \"%s\") " +
                        "|> filter(fn: (r) => r[\"_field\"] == \"%s\") " +
                        "|> aggregateWindow(every: %s, fn: %s, createEmpty: false)",
                influxDBConfig.getBucket(),
                deviceId,
                field,
                window,
                aggregation);

        List<Map<String, Object>> rawDataList = executeQueryList(flux);

        // ‚úÖ TH√äM: Log debug
        log.info("üîç [Aggregated Query] Device: {}, Field: {}, Window: {}, Results: {}",
                deviceId, field, window, rawDataList.size());

        if (rawDataList.isEmpty()) {
            log.warn("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu aggregated cho device: {}, field: {}", deviceId, field);
            return Collections.emptyList(); // ‚úÖ Tr·∫£ v·ªÅ list r·ªóng thay v√¨ l·ªói
        }

        return rawDataList.stream()
                .map(data -> {
                    SensorDataDTO dto = SensorDataDTO.fromInfluxRecord(data);

                    // ‚úÖ S·ª¨A: X·ª≠ l√Ω null
                    Object valueObj = data.get("_value");
                    if (valueObj != null) {
                        if (valueObj instanceof Number) {
                            dto.setAvgValue(((Number) valueObj).doubleValue());
                        } else {
                            log.warn("‚ö†Ô∏è Value kh√¥ng ph·∫£i s·ªë: {}", valueObj);
                        }
                    }

                    return dto;
                })
                .filter(dto -> dto.getAvgValue() != null) // ‚úÖ L·ªçc b·ªè c√°c record null
                .collect(Collectors.toList());
    }

    /**
     * Get all devices data for a farm
     */
    public Map<String, Map<String, Object>> getFarmLatestData(Long farmId) {
        String flux = String.format(
                "from(bucket: \"%s\") " +
                        "|> range(start: -1h) " +
                        "|> filter(fn: (r) => r[\"farm_id\"] == \"%s\") " +
                        "|> last()",
                influxDBConfig.getBucket(),
                farmId);

        List<Map<String, Object>> results = executeQueryList(flux);
        Map<String, Map<String, Object>> deviceDataMap = new HashMap<>();

        for (Map<String, Object> record : results) {
            String deviceId = (String) record.get("device_id");
            deviceDataMap.putIfAbsent(deviceId, new HashMap<>());

            String field = record.get("_field").toString();
            Object value = record.get("_value");

            deviceDataMap.get(deviceId).put(field, value);
            deviceDataMap.get(deviceId).put("device_id", deviceId);
            deviceDataMap.get(deviceId).put("timestamp", record.get("_time"));
        }

        return deviceDataMap;
    }

    // Helper methods
    private Map<String, Object> executeQuery(String flux) {
        QueryApi queryApi = influxDBClient.getQueryApi();
        List<FluxTable> tables = queryApi.query(flux, influxDBConfig.getOrg());

        if (tables.isEmpty() || tables.get(0).getRecords().isEmpty()) {
            return new HashMap<>();
        }

        return fluxRecordToMap(tables.get(0).getRecords().get(0));
    }

    private List<Map<String, Object>> executeQueryList(String flux) {
        try {
            QueryApi queryApi = influxDBClient.getQueryApi();
            List<FluxTable> tables = queryApi.query(flux, influxDBConfig.getOrg());

            // ‚úÖ TH√äM: Log debug
            log.debug("üîç [InfluxDB] Query executed, tables count: {}", tables.size());

            if (tables.isEmpty()) {
                return Collections.emptyList(); // ‚úÖ Tr·∫£ v·ªÅ list r·ªóng
            }

            List<Map<String, Object>> results = new ArrayList<>();
            for (FluxTable table : tables) {
                for (FluxRecord record : table.getRecords()) {
                    Map<String, Object> data = new HashMap<>();

                    // ‚úÖ S·ª¨A: X·ª≠ l√Ω null an to√†n
                    Object value = record.getValue();
                    if (value != null) {
                        data.put("_value", value);
                    } else {
                        log.warn("‚ö†Ô∏è Record c√≥ value null, b·ªè qua");
                        continue; // Skip record n√†y
                    }

                    data.put("_time", record.getTime());
                    data.put("_field", record.getField());
                    data.put("device_id", record.getValueByKey("device_id"));

                    results.add(data);
                }
            }

            return results;

        } catch (Exception e) {
            log.error("‚ùå [InfluxDB] L·ªói query: {}", e.getMessage(), e);
            return Collections.emptyList(); // ‚úÖ Tr·∫£ v·ªÅ list r·ªóng thay v√¨ throw exception
        }
    }

    private Map<String, Object> fluxRecordToMap(FluxRecord record) {
        Map<String, Object> map = new HashMap<>();
        map.put("_time", record.getTime());
        map.put("_value", record.getValue());
        map.put("_field", record.getField());
        map.putAll(record.getValues());
        return map;
    }

    /**
     * L·∫•y d·ªØ li·ªáu c·∫£m bi·∫øn m·ªõi nh·∫•t theo farmId
     */
    public SensorDataDTO getLatestSensorDataByFarmId(Long farmId) {
        try {
            String query = String.format(
                    "from(bucket: \"%s\") " +
                            "|> range(start: -1h) " +
                            "|> filter(fn: (r) => r[\"_measurement\"] == \"sensor_data\") " +
                            "|> filter(fn: (r) => r[\"farm_id\"] == \"%s\") " +
                            "|> last()",
                    influxDBConfig.getBucket(),
                    farmId);

            log.debug("üîç [InfluxDB] Query for farmId {}: {}", farmId, query);

            QueryApi queryApi = influxDBClient.getQueryApi();
            List<FluxTable> tables = queryApi.query(query);

            if (tables == null || tables.isEmpty()) {
                log.warn("‚ö†Ô∏è [InfluxDB] Kh√¥ng c√≥ d·ªØ li·ªáu cho farmId: {}", farmId);
                return null;
            }

            // Parse d·ªØ li·ªáu
            SensorDataDTO data = new SensorDataDTO();
            data.setFarmId(farmId);
            data.setTimestamp(Instant.now());

            for (FluxTable table : tables) {
                for (FluxRecord record : table.getRecords()) {
                    String field = (String) record.getField();
                    Object value = record.getValue();

                    switch (field) {
                        case "temperature":
                            data.setTemperature(((Number) value).doubleValue());
                            break;
                        case "humidity":
                            data.setHumidity(((Number) value).doubleValue());
                            break;
                        case "soil_moisture":
                            data.setSoilMoisture(((Number) value).doubleValue());
                            break;
                        case "light_intensity":
                            data.setLightIntensity(((Number) value).doubleValue());
                            break;
                        case "soilPH":
                            data.setSoilPH(((Number) value).doubleValue());
                            break;
                    }
                }
            }

            log.info("‚úÖ [InfluxDB] L·∫•y d·ªØ li·ªáu th√†nh c√¥ng cho farmId: {}", farmId);
            return data;

        } catch (Exception e) {
            log.error("‚ùå [InfluxDB] L·ªói khi l·∫•y d·ªØ li·ªáu farmId {}: {}", farmId, e.getMessage());
            return null;
        }
    }

    /**
     * L·∫•y d·ªØ li·ªáu c·∫£m bi·∫øn t·∫°i th·ªùi ƒëi·ªÉm c·ª• th·ªÉ
     * (D√πng cho quy t·∫Øc 5: ƒë·ªô ·∫©m dao ƒë·ªông)
     */
    public SensorDataDTO getSensorDataAt(Long farmId, LocalDateTime dateTime) {
        try {
            String query = String.format(
                    "from(bucket: \"%s\") " +
                            "|> range(start: %s, stop: %s) " +
                            "|> filter(fn: (r) => r[\"_measurement\"] == \"sensor_data\") " +
                            "|> filter(fn: (r) => r[\"farm_id\"] == \"%s\") " +
                            "|> last()",
                    influxDBConfig.getBucket(),
                    dateTime.minusMinutes(30).toString() + "Z",
                    dateTime.plusMinutes(30).toString() + "Z",
                    farmId);

            log.debug("üîç [InfluxDB] Query for farmId {}: {}", farmId, query);

            QueryApi queryApi = influxDBClient.getQueryApi();
            List<FluxTable> tables = queryApi.query(query);

            if (tables == null || tables.isEmpty()) {
                log.warn("‚ö†Ô∏è [InfluxDB] Kh√¥ng c√≥ d·ªØ li·ªáu cho farmId: {}", farmId);
                return null;
            }

            // Parse d·ªØ li·ªáu
            SensorDataDTO data = new SensorDataDTO();
            data.setFarmId(farmId);
            data.setTimestamp(Instant.now());

            for (FluxTable table : tables) {
                for (FluxRecord record : table.getRecords()) {
                    String field = (String) record.getField();
                    Object value = record.getValue();

                    switch (field) {
                        case "temperature":
                            data.setTemperature(((Number) value).doubleValue());
                            break;
                        case "humidity":
                            data.setHumidity(((Number) value).doubleValue());
                            break;
                        case "soil_moisture":
                            data.setSoilMoisture(((Number) value).doubleValue());
                            break;
                        case "light_intensity":
                            data.setLightIntensity(((Number) value).doubleValue());
                            break;
                        case "soilPh":
                            data.setSoilPH(((Number) value).doubleValue());
                            break;
                    }
                }
            }

            log.info("‚úÖ [InfluxDB] L·∫•y d·ªØ li·ªáu th√†nh c√¥ng cho farmId: {}", farmId);
            return data;

        } catch (Exception e) {
            log.error("‚ùå [InfluxDB] L·ªói khi l·∫•y d·ªØ li·ªáu farmId {}: {}", farmId, e.getMessage());
            return null;
        }
    }

    /**
     * üîç DEBUG: Ki·ªÉm tra d·ªØ li·ªáu sensor c√≥ t·ªìn t·∫°i kh√¥ng
     */
    public boolean hasRecentData(String deviceId, int hoursBack) {
        try {
            String query = String.format(
                    "from(bucket: \"%s\")\n" +
                            "  |> range(start: -%dh)\n" +
                            "  |> filter(fn: (r) => r[\"_measurement\"] == \"sensor_data\")\n" +
                            "  |> filter(fn: (r) => r[\"device_id\"] == \"%s\")\n" +
                            "  |> count()",
                    influxDBConfig.getBucket(), hoursBack, deviceId);

            QueryApi queryApi = influxDBClient.getQueryApi();
            List<FluxTable> tables = queryApi.query(query, influxDBConfig.getOrg());

            if (!tables.isEmpty() && !tables.get(0).getRecords().isEmpty()) {
                Object count = tables.get(0).getRecords().get(0).getValue();
                long recordCount = count != null ? ((Number) count).longValue() : 0;
                log.info("üîç Device {} c√≥ {} b·∫£n ghi trong {}h qua", deviceId, recordCount, hoursBack);
                return recordCount > 0;
            }

            log.warn("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu n√†o cho device {} trong {}h qua", deviceId, hoursBack);
            return false;

        } catch (Exception e) {
            log.error("‚ùå L·ªói ki·ªÉm tra d·ªØ li·ªáu: {}", e.getMessage());
            return false;
        }
    }
}
